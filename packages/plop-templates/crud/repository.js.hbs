import { prisma } from '@app/clients/prismaClient';
import { logger } from '@shared/core/utils';

/**
 * {{pascalCase entityName}} Repository
 * Data access layer for {{camelCase entityName}} operations
 */
export class {{pascalCase entityName}}Repository {
{{#if (includes operations "create")}}
  /**
   * Create a new {{camelCase entityName}}
   * @param {Object} data - {{pascalCase entityName}} data
   * @returns {Promise<Object>} Created {{camelCase entityName}}
   */
  static async create(data) {
    try {
      const {{camelCase entityName}} = await prisma.{{camelCase entityName}}.create({
        data
      });
      
      return {{camelCase entityName}};
    } catch (error) {
      logger.error('Error creating {{camelCase entityName}} in database:', error);
      throw error;
    }
  }
{{/if}}

{{#if (includes operations "getAll")}}
  /**
   * Find many {{camelCase entityName}}s with pagination and filtering
   * @param {Object} options - Query options
   * @returns {Promise<Object>} Paginated results
   */
  static async findMany(options = {}) {
    try {
      const {
        page = 1,
        limit = 10,
        search,
        sortBy = 'createdAt',
        sortOrder = 'desc'
      } = options;

      const skip = (page - 1) * limit;
      
      // Build where clause for search
      const where = search ? {
        OR: [
          { name: { contains: search, mode: 'insensitive' } },
          // Add other searchable fields here
        ]
      } : {};

      // Build orderBy clause
      const orderBy = {
        [sortBy]: sortOrder
      };

      // Execute queries in parallel
      const [{{camelCase entityName}}s, total] = await Promise.all([
        prisma.{{camelCase entityName}}.findMany({
          where,
          skip,
          take: limit,
          orderBy
        }),
        prisma.{{camelCase entityName}}.count({ where })
      ]);

      const totalPages = Math.ceil(total / limit);

      return {
        {{camelCase entityName}}s,
        total,
        page,
        limit,
        totalPages
      };
    } catch (error) {
      logger.error('Error finding {{camelCase entityName}}s in database:', error);
      throw error;
    }
  }
{{/if}}

{{#if (includes operations "getById")}}
  /**
   * Find {{camelCase entityName}} by ID
   * @param {string} id - {{pascalCase entityName}} ID
   * @returns {Promise<Object|null>} {{pascalCase entityName}} or null
   */
  static async findById(id) {
    try {
      const {{camelCase entityName}} = await prisma.{{camelCase entityName}}.findUnique({
        where: { id }
      });
      
      return {{camelCase entityName}};
    } catch (error) {
      logger.error(`Error finding {{camelCase entityName}} by ID ${id}:`, error);
      throw error;
    }
  }
{{/if}}

{{#if (includes operations "update")}}
  /**
   * Update {{camelCase entityName}} by ID
   * @param {string} id - {{pascalCase entityName}} ID
   * @param {Object} data - Update data
   * @returns {Promise<Object>} Updated {{camelCase entityName}}
   */
  static async update(id, data) {
    try {
      const {{camelCase entityName}} = await prisma.{{camelCase entityName}}.update({
        where: { id },
        data
      });
      
      return {{camelCase entityName}};
    } catch (error) {
      logger.error(`Error updating {{camelCase entityName}} with ID ${id}:`, error);
      throw error;
    }
  }
{{/if}}

{{#if (includes operations "delete")}}
  /**
   * Delete {{camelCase entityName}} by ID
   * @param {string} id - {{pascalCase entityName}} ID
   * @returns {Promise<Object>} Deleted {{camelCase entityName}}
   */
  static async delete(id) {
    try {
      const {{camelCase entityName}} = await prisma.{{camelCase entityName}}.delete({
        where: { id }
      });
      
      return {{camelCase entityName}};
    } catch (error) {
      logger.error(`Error deleting {{camelCase entityName}} with ID ${id}:`, error);
      throw error;
    }
  }
{{/if}}

  /**
   * Check if {{camelCase entityName}} exists by ID
   * @param {string} id - {{pascalCase entityName}} ID
   * @returns {Promise<boolean>} True if exists
   */
  static async exists(id) {
    try {
      const count = await prisma.{{camelCase entityName}}.count({
        where: { id }
      });
      
      return count > 0;
    } catch (error) {
      logger.error(`Error checking if {{camelCase entityName}} exists with ID ${id}:`, error);
      throw error;
    }
  }

  /**
   * Get {{camelCase entityName}} statistics
   * @returns {Promise<Object>} Statistics
   */
  static async getStatistics() {
    try {
      const [total, recentCount] = await Promise.all([
        prisma.{{camelCase entityName}}.count(),
        prisma.{{camelCase entityName}}.count({
          where: {
            createdAt: {
              gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
            }
          }
        })
      ]);

      return {
        total,
        recentCount,
        lastUpdated: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Error getting {{camelCase entityName}} statistics:', error);
      throw error;
    }
  }
}

export default {{pascalCase entityName}}Repository;
